/*
Copyright (C) [2023] [Alexander Volya]
This code is licensed under the GNU GPL v3, see LICENSE file 
For more details and acknowledgments, see the NOTICE file.
*/


/*
region for l1 is fixed, make sure it is between min and max
 */
#ifndef __SIXJSYMBOL_CXX__
#define __SIXJSYMBOL_CXX__
#include <cmath>
#ifndef WPrint  //if debug is used this will be defined
#define WPrint(x)  //by default disable waringngs
#endif
#ifndef DBL_MAX
#define DBL_MAX  1.797693134862315e+308
#endif
#define MAX(a,b) ((a>b)?a:b)
#define MIN(a,b) ((a<b)?a:b)
#define COPYSIGN(x,y) ((y < 0) ? ((x < 0) ? x : -x) : ((x > 0) ? x : -x))
//#define ROUND(d) ((d>0) ? (int)(d+0.5) : -(int)(-d+0.5))
//#define ABS(a) ((a>0)?a:-a)
#define ODD(a) (a&1)
// SixJSymbol() - Wigner 6j symbols         

//-----------------------------------------------------------------------------//
//
// void SixJSymbol (double l2, double l3, double l4, 
//                  double l5, double l6, double &l1min, double &l1max, 
//                  double *sixcof, int ndim, int &errflag)
//
// Evaluate the 6j symbol 
//
//      h(l1) = { l1  l2  l3 }
//              { l4  l5  l6 } 
//
// for all allowed values of l1, the other parameters  being held fixed. 
//
// Input Arguments:
// ----------------
//
//   double l2
//   double l3
//   double l4
//   double l5
//   double l6     	Parameters in 6j symbol.
//
//   int  ndim 	   	Declared length of sixcof in calling program.
//
// Output Arguments:
// -----------------
//
//   double &l1min	Smallest allowable l1 in 6j symbol.
//   double &l1max 	Largest allowable l1 in 6j symbol. 
//   double *sixcof     Set of 6j coefficients generated by evaluating the 
//                      6j symbol for all allowed values of l1. sixcof(i) 
//                      will contain h(l1min+i), i=0,2,...,l1max-l1min. 
//
//   int &errflag	Error flag. 
//                      errflag=0  no errors. 
//                      errflag=1  l2+l3+l5+l6 or l4+l2+l6 not an integer. 
//                      errflag=2  l4, l2, l6 triangular condition not satisfied. 
//                      errflag=3  l4, l5, l3 triangular condition not satisfied. 
//                      errflag=4  l1max-l1min not an integer. 
//                      errflag=5  l1max less than l1min. 
//                      errflag=6  ndim less than l1max-l1min+1. 
//
// Description:
// ------------
//
//  The definition and properties of 6j symbols can be found, for 
//  example, in Appendix C of Volume II of A. Messiah. Although the 
//  parameters of the vector addition coefficients satisfy certain 
//  conventional restrictions, the restriction that they be non-negative 
//
//  integers or non-negative integers plus 1/2 is not imposed on input 
//  to this subroutine. The restrictions imposed are 
//
//       1. l2+l3+l5+l6 and l2+l4+l6 must be integers; 
//       2. abs(l2-l4) <= l6 <= l2+l4 must be satisfied; 
//       3. abs(l4-l5) <= l3 <= l4+l5 must be satisfied; 
//       4. l1max-l1min must be a non-negative integer, where 
//          l1max=min(l2+l3,l5+l6) and l1min=max(abs(l2-l3),abs(l5-l6)). 
//
//  If all the conventional restrictions are satisfied, then these 
//  restrictions are met. Conversely, if input to this subroutine meets 
//  all of these restrictions and the conventional restriction stated 
//  above, then all the conventional restrictions are satisfied. 
//
//  The user should be cautious in using input parameters that do 
//  not satisfy the conventional restrictions. For example, the 
//  the subroutine produces values of 
//
//       h(L1) = {  L1  2/3   1  } 
//               { 2/3  2/3  2/3 } 
//
//  for L1=1/3 and 4/3 but none of the symmetry properties of the 6j 
//  symbol, set forth on pages 1063 and 1064 of Messiah, is satisfied. 
//
//  The subroutine generates h(l1min), h(l1min+1), ..., h(l1max) 
//  where l1min and l1max are defined above. The sequence h(l1) is 
//  generated by a three-term recurrence algorithm with scaling to 
//  control overflow. Both backward and forward recurrence are used to 
//  maintain numerical stability. The two recurrence sequences are 
//  matched at an interior point and are normalized from the unitary 
//  property of 6j coefficients and Wigner's phase convention. 
//
//  The algorithm is suited to applications in which large quantum 
//  numbers arise, such as in molecular dynamics. 
//
// References:
// -----------
// 1. Messiah, Albert., Quantum Mechanics, Volume II, 
//    North-Holland Publishing Company, 1963. 
// 2. Schulten, Klaus and Gordon, Roy G., Exact recursive 
//    evaluation of 3j and 6j coefficients for quantum- 
//    mechanical coupling of angular momenta, J Math 
//    Phys, v 16, no. 10, October 1975, pp. 1961-1970. 
// 3. Schulten, Klaus and Gordon, Roy G., Semiclassical 
//    approximations to 3j and 6j coefficients for 
//    quantum-mechanical coupling of angular momenta, 
//    J Math Phys, v 16, no. 10, October 1975, 
//    pp. 1971-1988. 
// 4. Schulten, Klaus and Gordon, Roy G., Recursive 
//    evaluation of 3j and 6j coefficients, Computer 
//    Phys Comm, v 11, 1976, pp. 269-278. 
// 5. SLATEC  library, category  C19, 
//    double precision algorithm DRC6J.F
//    Keywords: 6j coefficients, 6j symbols, Clebsch-Gordan coefficients, 
//             Racah coefficients, vector addition coefficients, 
//             Wigner coefficients 
//     Author:   Gordon, R. G., Harvard University
//               Schulten, K., Max Planck Institute
//     Revision history  (YYMMDD)
//     750101  DATE WRITTEN 
//     880515  SLATEC prologue added by G. C. Nielson, NBS; parameters 
//             HUGE and TINY revised to depend on D1MACH. 
//     891229  Prologue description rewritten; other prologue sections 
//             revised; LMATCH (location of match point for recurrences) 
//             removed from argument list; argument IER changed to serve 
//             only as an error flag (previously, in cases without error, 
//             it returned the number of scalings); number of error codes 
//             increased to provide more precise error information; 
//             program comments revised; SLATEC error handler calls 
//             introduced to enable printing of error messages to meet 
//             SLATEC standards. These changes were done by D. W. Lozier, 
//             M. A. McClain and J. M. Smith of the National Institute 
//             of Standards and Technology, formerly NBS. 
//     910415  Mixed type expressions eliminated; variable C1 initialized; 
//             description of SIXCOF expanded. These changes were done by 
//             D. W. Lozier. 

//-----------------------------------------------------------------------------//

namespace mav {
void SixJSymbol (double l2, double l3, double l4, 
		 double l5, double l6, double &l1min, double &l1max, 
		 double *sixcof, int ndim, int &errflag)
{
  const double zero = 0.0, eps = 0.01, one = 1.0, two = 2.0, three = 3.0;

  int nfin, nlim, i, n, index, lstep, nfinp1, nfinp2, nfinp3, nstep2;
  double c1old = 0.0, sign1, sign2, x, y, denom = 0.0, cnorm, ratio, 
         a1, a2, c1, c2, l1, x1, x2, x3, y1, y2, y3, oldfac, dv, newfac, 
         sumbac = 0.0, thresh, a1s, a2s, sumfor, sumuni, sum1, sum2;

  // Parameter adjustments 
  --sixcof;

  errflag = 0;
  
  // "huge" is the square root of one twentieth of the largest floating 
  // point number, approximately. 
  double huge   = sqrt(DBL_MAX / 20.0),
         srhuge = sqrt(huge),
         tiny   = one / huge,
         srtiny = one / srhuge;

  // lmatch = zero 

  // Check error conditions 1, 2, and 3. 
  if (fmod(l2+l3+l5+l6+eps,one) >= eps + eps 
      || fmod(l4+l2+l6+eps, one) >= eps + eps) {
    errflag = 1;
   WPrint(
		  "l2+l3+l5+l6 or l4+l2+l6 not integer.");
    return;
  } else if (l4+l2-l6 < zero || l4-l2+l6 < zero || -l4+l2+l6 < zero) {
    errflag = 2;
   WPrint(
		  "L4, L2, L6 triangular condition not satisfied.");
    return;
  } else if (l4-l5+l3 < zero || l4+l5-l3 < zero || -l4+l5+l3 < zero) {
    errflag = 3;
   WPrint(
		  "L4, L5, L3 triangular condition not satisfied.");
    return;
  }

  // Limits for l1 
  l1min = MAX(fabs(l2-l3),fabs(l5-l6));
  l1max = MIN(l2+l3,l5+l6);

  // Check error condition 4. 
  if (fmod(l1max-l1min+eps,one) >= eps + eps) {
    errflag = 4;
   WPrint(
		  "l1max-l1min not integer.");
    return;
  }
  if (l1min < l1max - eps) goto L20;
  if (l1min < l1max + eps) goto L10;

  // Check error condition 5. 
  errflag = 5;
 WPrint(
		"l1min greater than l1max.");
  return;

  // This is reached in case that l1 can take only one value 

L10:
  // lscale = 0 
  sixcof[1] = (ODD(int(l2+l3+l5+l6+eps)) ? -one : one)
                 / sqrt((l1min+l1min+one)*(l4+l4+one));
  return;

  // This is reached in case that l1 can take more than one value. 

L20:
  // lscale = 0 
  nfin = int(l1max-l1min+one+eps);
  if (ndim - nfin >= 0) goto L23;

  // Check error condition 6. 
  errflag = 6;
 WPrint(
		"Dimension of result array for 6j coefficients too small.");
  return;

  // Start of forward recursion 

L23:
  l1 = l1min;
  newfac = 0.0;
  c1 = 0.0;
  sixcof[1] = srtiny;
  sum1 = (l1 + l1 + one) * tiny;

  lstep = 1;
L30:
  ++lstep;
  l1 += one;

  oldfac = newfac;
  a1 = (l1+l2+l3+one) * (l1-l2+l3) * (l1+l2-l3) * (-l1+l2+l3+one);
  a2 = (l1+l5+l6+one) * (l1-l5+l6) * (l1+l5-l6) * (-l1+l5+l6+one);
  newfac = sqrt(a1 * a2);

  if (l1 < one + eps) goto L40;

  dv = two * (l2 * (l2+one) * l5 * (l5+one) + l3 * (l3+one) * l6 * (l6+one) 
	      - l1 * (l1-one) * l4 * (l4+one)) 
                        - (l2 * (l2+one) + l3 * (l3+one) - l1 * (l1-one)) 
                        * (l5 * (l5+one) + l6 * (l6+one) - l1 * (l1-one));

  denom = (l1-one) * newfac;

  if (lstep - 2 <= 0) goto L32;
  c1old = fabs(c1);

L32:
  c1 = -(l1+l1-one) * dv / denom;
  goto L50;

  // if l1 = 1, (l1 - 1) has to be factored out of dv, hence 

L40:
  c1 = -two * (l2 * (l2+one) + l5 * (l5+one) - l4 * (l4+one)) / newfac;

L50:
  if (lstep > 2) goto L60;

  // If l1 = l1min + 1, the third term in recursion equation vanishes 

  x = srtiny * c1;
  sixcof[2] = x;
  sum1 += tiny * (l1+l1+one) * c1 * c1;

  if (lstep == nfin) goto L220;
  goto L30;


L60:
  c2 = -l1 * oldfac / denom;

  // Recursion to the next 6j coefficient x 

  x = c1 * sixcof[lstep-1] + c2 * sixcof[lstep-2];
  sixcof[lstep] = x;

  sumfor = sum1;
  sum1 += (l1+l1+one) * x * x;
  if (lstep == nfin) goto L100;

  // See if last unnormalized 6j coefficient exceeds srhuge 

  if (fabs(x) < srhuge) goto L80;

  // This is reached if last 6j coefficient larger than srhuge, 
  // so that the recursion series sixcof(1), ... ,sixcof(lstep) 
  // has to be rescaled to prevent overflow 

  // lscale = lscale + 1 
  for (i = 1; i <= lstep; ++i) {
    if (fabs(sixcof[i]) < srtiny) sixcof[i] = zero;
    sixcof[i] /= srhuge;
  }
  sum1 /= huge;
  sumfor /= huge;
  x /= srhuge;

  // As long as the coefficient fabs(c1) is decreasing, the recursion 
  // proceeds towards increasing 6j values and, hence, is numerically 
  // stable.  Once an increase of abs(c1) is detected, the recursion 
  // direction is reversed. 

L80:
  if (c1old - fabs(c1) <= 0.0) 
    goto L100;
  else
    goto L30;

  // Keep three 6j coefficients around lmatch for comparison later 
  // with backward recursion. 

L100:
  // lmatch = l1 - 1 
  x1 = x;
  x2 = sixcof[lstep-1];
  x3 = sixcof[lstep-2];

  // Starting backward recursion from l1max taking nstep2 steps, so 
  // that forward and backward recursion overlap at the three points 
  // l1 = lmatch+1, lmatch, lmatch-1. 

  nfinp1 = nfin + 1;
  nfinp2 = nfin + 2;
  nfinp3 = nfin + 3;
  nstep2 = nfin - lstep + 3;
  l1 = l1max;

  sixcof[nfin] = srtiny;
  sum2 = (l1 + l1 + one) * tiny;

  l1 += two;
  lstep = 1;
L110:
  ++lstep;
  l1 -= one;

  oldfac = newfac;
  a1s = (l1+l2+l3) * (l1-l2+l3-one) * (l1+l2-l3-one) * (-l1+l2+l3+two);
  a2s = (l1+l5+l6) * (l1-l5+l6-one) * (l1+l5-l6-one) * (-l1+l5+l6+two);
  newfac = sqrt(a1s * a2s);

  dv = two * (l2 * (l2+one) * l5 * (l5+one) + l3 * (l3+one) * l6 * (l6+one) 
	      - l1 * (l1-one) * l4 * (l4+one)) 
                        - (l2 * (l2+one) + l3 * (l3+one) - l1 * (l1-one)) 
                        * (l5 * (l5+one) + l6 * (l6+one) - l1 * (l1-one));

  denom = l1 * newfac;
  c1 = -(l1+l1-one) * dv / denom;
  if (lstep > 2) goto L120;

  // If l1 = l1max + 1 the third term in the recursion equation vanishes 

  y = srtiny * c1;
  sixcof[nfin - 1] = y;
  if (lstep == nstep2) goto L200;
  sumbac = sum2;
  sum2 += (l1+l1-three) * c1 * c1 * tiny;
  goto L110;

L120:
  c2 = -(l1-one) * oldfac / denom;

  // Recursion to the next 6j coefficient y 

  y = c1 * sixcof[nfinp2 - lstep] + c2 * sixcof[nfinp3 - lstep];
  if (lstep == nstep2) goto L200;

  sixcof[nfinp1 - lstep] = y;
  sumbac = sum2;
  sum2 += (l1+l1-three) * y * y;

  // See if last unnormalized 6j coefficient exceeds srhuge 

  if (fabs(y) < srhuge) goto L110;

  // This is reached if last 6j coefficient larger than srhuge, 
  // so that the recursion series sixcof(nfin), ... ,sixcof(nfin-lstep+1) 
  // has to be rescaled to prevent overflow 

  // lscale = lscale + 1 
  for (i = 1; i <= lstep; ++i) {
    index = nfin - i + 1;
    if (fabs(sixcof[index]) < srtiny) sixcof[index] = zero;
    sixcof[index] /= srhuge;
  }
  sumbac /= huge;
  sum2 /= huge;

  goto L110;
  
  // The forward recursion 6j coefficients x1, x2, x3 are to be matched 
  // with the corresponding backward recursion values y1, y2, y3. 

L200:
  y3 = y;
  y2 = sixcof[nfinp2 - lstep];
  y1 = sixcof[nfinp3 - lstep];

  // Determine now ratio such that yi = ratio * xi  (i=1,2,3) holds 
  // with minimal error. 

  ratio = (x1*y1 + x2*y2 + x3*y3) / (x1*x1 + x2*x2 + x3*x3);
  nlim = nfin - nstep2 + 1;

  if (fabs(ratio) < one) goto L211;

  for (n = 1; n <= nlim; ++n) 
    sixcof[n] = ratio * sixcof[n];
  sumuni = ratio * ratio * sumfor + sumbac;
  goto L230;

L211:
  ++nlim;
  ratio = one / ratio;
  for (n = nlim; n <= nfin; ++n)
    sixcof[n] = ratio * sixcof[n];
  sumuni = sumfor + ratio * ratio * sumbac;
  goto L230;
  
L220:
  sumuni = sum1;

  // Normalize 6j coefficients 

L230:
  cnorm = one / sqrt((l4+l4+one) * sumuni);

  // Sign convention for last 6j coefficient determines overall phase 

  sign1 = COPYSIGN(one,sixcof[nfin]);
  sign2 = ODD(int(l2+l3+l5+l6+eps)) ? -one : one;
  if (sign1 * sign2 <= 0.0) goto L235;
  else  goto L236;

L235:
  cnorm = -cnorm;

L236:
  if (fabs(cnorm) < one) goto L250;

  for (n = 1; n <= nfin; ++n) 
    sixcof[n] = cnorm * sixcof[n];
  return;

L250:
  thresh = tiny / fabs(cnorm);
  for (n = 1; n <= nfin; ++n) {
    if (fabs(sixcof[n]) < thresh) sixcof[n] = zero;
    sixcof[n] = cnorm * sixcof[n];
  }
} 
#undef MAX
#undef MIN
#undef COPYSIGN
#undef ODD


double  SixJSymbol (double l1, double l2, double l3, double l4, 
		      double l5, double l6) {

	 double l1min = fabs(l2-l3);
         double l1max = (l2+l3);

  int    ndim = int(l1max-l1min+1+0.1), errflag;

  double *sixcof = new double[ndim];
  SixJSymbol (l2, l3, l4, l5, l6, l1min, l1max, 
	      sixcof, ndim, errflag);
    if (errflag!=0) {delete[] sixcof; return 0.;}
    if ((l1<l1min-0.1)||(l1>l1max+0.1)) {delete[] sixcof; return 0.;}
  double ret=sixcof[int(l1-l1min+0.1)];

    delete[] sixcof;
  return ret;
		      }

} //namespace end
//-----------------------------------------------------------------------------//
#endif 

