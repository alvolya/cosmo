/*
Copyright (C) [2023] [Alexander Volya]
This code is licensed under the GNU GPL v3, see LICENSE file 
For more details and acknowledgments, see the NOTICE file.
*/


/*
09/17/07
ThreeJSymbol check for |m|<=j for all input;
 */
#ifndef __THREEJSYMBOL_CXX__
#define __THREEJSYMBOL_CXX__
#include <cmath>
#ifndef WPrint  //if debug is used this will be defined
#define WPrint(x)  //by default disable waringngs
#endif
#ifndef DBL_MAX
#define DBL_MAX  1.797693134862315e+308
#endif
#define MAX(a,b) ((a>b)?a:b)
#define MIN(a,b) ((a<b)?a:b)
#define COPYSIGN(x,y) ((y < 0) ? ((x < 0) ? x : -x) : ((x > 0) ? x : -x))
//#define ROUND(d) ((d>0) ? (int)(d+0.5) : -(int)(-d+0.5))
//#define ABS(a) ((a>0)?a:-a)
#define ODD(a) (a&1)
#ifndef PARITY
#define PARITY(a) (1-(((a)&1)<<1))
#endif
//#include "double.h"
//#include "basic.h"
//#include <cmath>


/*-----------------------------------------------------------------------------*\
| Matpack special functions - ThreeJSymbolM() - Wigner 3j symbols    threejm.cc |
|                                                                               |
| Last change: Jun 13, 2001							|
|                                                                               |
| Matpack Library Release 1.6.2                                                 |
| Copyright (C) 1991-2001 by Berndt M. Gammel. All rights reserved.             |
|                                                                               |
| Permission to  use, copy, and  distribute  Matpack  in  its entirety  and its |
| documentation  for non-commercial purpose and  without fee is hereby granted, |
| provided that this license information and copyright notice appear unmodified |
| in all copies.  This software is provided 'as is'  without express or implied |
| warranty.  In no event will the author be held liable for any damages arising |
| from the use of this software.                                                |
| Note that distributing Matpack 'bundled' in with any product is considered to |
| be a 'commercial purpose'.                                                    |
| The software may be modified for your own purposes, but modified versions may |
| not be distributed without prior consent of the author.                       |
|                                                                               |
| Read the  COPYRIGHT and  README files in this distribution about registration |
| and installation of Matpack.                                                  |
|                                                                               |
\*-----------------------------------------------------------------------------*/
// SOME NOTES WHEN CONVERTING FORTRAN ROUTINES TO C++
// r1mach(n) returns:
//      FORTRAN                             C++
// d(1)=2.225073858507201e-308   DBL_MIN = 2.225073858507201e-308
//#define DBL_MAX  1.797693134862315e+308
//#include "compat.h"
//#include <unistd.h>
//#include <stdlib.h>
//#include <string.h>
// d(3)=1.110223024625157e-16    0.5 * DBL_EPSILON
// d(4)=2.220446049250313e-16    DBL_EPSILON= 2.220446049250313e-16
// d(5)=0.3010299956639812       log10(basis)
// double d_int(double*) rounds towards zero

//-----------------------------------------------------------------------------//
//
// void ThreeJSymbolM (double l1, double l2, double l3, double m1, 
//                     double &m2min, double &m2max, double *thrcof, int ndim, 
//                     int &errflag)
//
// Evaluate the Wigner 3j symbol 
//
//       g(m2) = ( l1  l2     l3  )
//               ( m1  m2  -m1-m2 )
// 
// for all allowed values of m2, the other parameters being held fixed.
//
// Input Arguments:
// ----------------
//
//   double l1 
//   double l2
//   double l3
//   double m1		Parameters in 3j symbol.
//
//   int  ndim 		Declared length of thrcof in calling program.
//
// Output Arguments:
// -----------------
//
//   double &m2min	Smallest allowable m2 in 3j symbol.
//   double &m2max	Largest allowable m2 in 3j symbol.
//   double *thrcof	Set of 3j coefficients generated by evaluating the
//                      3j symbol for all allowed values of m2.  thrcof(i)
//                      will contain g(m2min+i), i=0,2,...,m2max-m2min.
//
//   int &errflag	Error flag.
//                 	errflag=0  No errors.
//                 	errflag=1  Either l1 < abs(m1) or l1+abs(m1) non-integer.
//                 	errflag=2  abs(l1-l2)<= l3 <= l1+l2 not satisfied.
//                 	errflag=3  l1+l2+l3 not an integer.
//                 	errflag=4  m2max-m2min not an integer.
//                 	errflag=5  m2max less than m2min.
//                 	errflag=6  ndim less than m2max-m2min+1.
// Description:
// ------------
//
// Although conventionally the parameters of the vector addition
// coefficients satisfy certain restrictions, such as being integers
// or integers plus 1/2, the restrictions imposed on input to this
// subroutine are somewhat weaker. See, for example, Section 27.9 of
// Abramowitz and Stegun or Appendix C of Volume II of A. Messiah.
//
// The restrictions imposed by this subroutine are
//
//       1. l1 >= abs(m1) and l1+abs(m1) must be an integer
//       2. abs(l1-l2) <= l3 <= l1+l2
//       3. l1+l2+l3 must be an integer
//       4. m2max-m2min must be an integer, where
//          m2max=min(l2,l3-m1) and m2min=max(-l2,-l3-m1)
//
// If the conventional restrictions are satisfied, then these
// restrictions are also met.
//
// The user should be cautious in using input parameters that do
// not satisfy the conventional restrictions. For example, the
// the subroutine produces values of
//       g(m2) = (0.75 1.50   1.75  )
//               (0.25  m2  -0.25-m2)
// for m2=-1.5,-0.5,0.5,1.5 but none of the symmetry properties of the
// 3j symbol, set forth on page 1056 of Messiah, is satisfied.
//
// The subroutine generates g(m2min), g(m2min+1), ..., g(m2max) 
// where m2min and m2max are defined above. The sequence g(m2) is 
// generated by a three-term recurrence algorithm with scaling to 
// control overflow. Both backward and forward recurrence are used to 
// maintain numerical stability. The two recurrence sequences are 
// matched at an interior point and are normalized from the unitary 
// property of 3j coefficients and Wigner's phase convention. 
//
// The algorithm is suited to applications in which large quantum 
// numbers arise, such as in molecular dynamics. 
//
// References:
// -----------
//  1. Abramowitz, M., and Stegun, I. A., Eds., Handbook
//     of Mathematical Functions with Formulas, Graphs
//     and Mathematical Tables, NBS Applied Mathematics
//     Series 55, June 1964 and subsequent printings.
//  2. Messiah, Albert., Quantum Mechanics, Volume II,
//     North-Holland Publishing Company, 1963.
//  3. Schulten, Klaus and Gordon, Roy G., Exact recursive
//     evaluation of 3j and 6j coefficients for quantum-
//     mechanical coupling of angular momenta, J Math
//     Phys, v 16, no. 10, October 1975, pp. 1961-1970.
//  4. Schulten, Klaus and Gordon, Roy G., Semiclassical
//     approximations to 3j  and 6j coefficients for
//     quantum-mechanical coupling of angular momenta,
//     J Math Phys, v 16, no. 10, October 1975, pp. 1971-1988.
//  5. Schulten, Klaus and Gordon, Roy G., Recursive
//     evaluation of 3j and 6j coefficients, Computer
//     Phys Comm, v 11, 1976, pp. 269-278.
//  6. SLATEC library, category  C19, 
//     double precision algorithm DRC3JM.F
//     Keywords: 3j coefficients, 3j symbols, Clebsch-Gordan coefficients, 
//               Racah coefficients, vector addition coefficients,
//               Wigner coefficients
//     Author:   Gordon, R. G., Harvard University
//               Schulten, K., Max Planck Institute
//     Revision history  (YYMMDD)
//     750101  DATE WRITTEN 
//     880515  SLATEC prologue added by G. C. Nielson, NBS; parameters 
//             HUGE and TINY revised to depend on D1MACH. 
//     891229  Prologue description rewritten; other prologue sections 
//             revised; MMATCH (location of match point for recurrences) 
//             removed from argument list; argument IER changed to serve 
//             only as an error flag (previously, in cases without error, 
//             it returned the number of scalings); number of error codes 
//             increased to provide more precise error information; 
//             program comments revised; SLATEC error handler calls 
//             introduced to enable printing of error messages to meet 
//             SLATEC standards. These changes were done by D. W. Lozier, 
//             M. A. McClain and J. M. Smith of the National Institute 
//             of Standards and Technology, formerly NBS. 
//     910415  Mixed type expressions eliminated; variable C1 initialized; 
//             description of THRCOF expanded. These changes were done by 
//             D. W. Lozier.
//  7. Rewritting of the SLATEX algorithm in C++ and adaption to the
//     Matpack C++ Numerics and Graphics Library by Berndt M. Gammel
//     in June 1997.
//
//-----------------------------------------------------------------------------//

namespace mav{

 

void ThreeJSymbolM (double l1, double l2, double l3, double m1, 
		    double &m2min, double &m2max, double *thrcof, int ndim, 
		    int &errflag)
{
  const double zero = 0.0, eps = 0.01, one = 1.0, two = 2.0;

  int nfin, nlim, i, n, index, lstep, nfinp1, nfinp2, nfinp3, nstep2;
  double oldfac, dv, newfac, sumbac = 0.0, thresh, a1s, sumfor, sumuni, 
         sum1, sum2, x, y, m2, m3, x1, x2, x3, y1, y2, y3, cnorm, 
         ratio, a1, c1, c2, c1old = 0.0, sign1, sign2;

  // Parameter adjustments
  --thrcof;

  errflag = 0;

  // "huge" is the square root of one twentieth of the largest floating
  // point number, approximately.
  double huge   = sqrt(DBL_MAX / 20.0),
         srhuge = sqrt(huge),
         tiny   = one / huge,
         srtiny = one / srhuge;

  // lmatch = zero

  //  Check error conditions 1, 2, and 3. 
  if (l1 - fabs(m1) + eps < zero 
      || fmod(l1 + fabs(m1) + eps, one) >= eps + eps) {
    errflag = 1;    
  WPrint("ThreeJSymbolM l1-fabs(m1) less than zero or l1+fabs(m1) not integer.");
    return;
  } else if (l1+l2-l3 < -eps || l1-l2+l3 < -eps || -(l1) + l2+l3 < -eps) {
    errflag = 2;
   WPrint("ThreeJSymbolM l1, l2, l3 do not satisfy triangular condition.");
    return;
  } else if (fmod(l1 + l2 + l3 + eps, one) >= eps + eps) {
      errflag = 3;
     WPrint("ThreeJSymbolM l1+l2+l3 not integer.");
      return;
  }

  // limits for m2 
  m2min = MAX(-l2,-l3-m1);
  m2max = MIN(l2,l3-m1);

  // Check error condition 4. 
  if (fmod(m2max - m2min + eps, one) >= eps + eps) {
    errflag = 4;
    WPrint(" ThreeJSymbolM m2max-m2min not integer.");
    return;
  }
  if (m2min < m2max - eps) goto L20;
  if (m2min < m2max + eps) goto L10;

  //  Check error condition 5. 
  errflag = 5;
  WPrint(" ThreeJSymbolM m2min greater than m2max.");
  return;

  // This is reached in case that m2 and m3 can take only one value. 
L10:
  // mscale = 0 
  thrcof[1] = (ODD(int(fabs(l2-l3-m1)+eps)) ? -one : one) / sqrt(l1+l2+l3+one);
  return;

  // This is reached in case that M1 and M2 take more than one value. 
L20:
  // mscale = 0 
  nfin = int(m2max - m2min + one + eps);
  if (ndim - nfin >= 0) goto L23;

  // Check error condition 6. 

  errflag = 6;
  WPrint("ThreeJSymbolM Dimension of result array for 3j coefficients too small.");
  return;

  //  Start of forward recursion from m2 = m2min 

L23:
  m2 = m2min;
  thrcof[1] = srtiny;
  newfac = 0.0;
  c1 = 0.0;
  sum1 = tiny;

  lstep = 1;
L30:
  ++lstep;
  m2 += one;
  m3 = -m1 - m2;

  oldfac = newfac;
  a1 = (l2 - m2 + one) * (l2 + m2) * (l3 + m3 + one) * (l3 - m3);
  newfac = sqrt(a1);

  dv = (l1+l2+l3+one) * (l2+l3-l1) - (l2-m2+one) * (l3+m3+one) 
                                   - (l2+m2-one) * (l3-m3-one);

  if (lstep - 2 > 0) c1old = fabs(c1);

// L32:
  c1 = -dv / newfac;

  if (lstep > 2) goto L60;

  //  If m2 = m2min + 1, the third term in the recursion equation vanishes,    
  //  hence 

  x = srtiny * c1;
  thrcof[2] = x;
  sum1 += tiny * c1 * c1;
  if (lstep == nfin) goto L220;
  goto L30;

L60:
  c2 = -oldfac / newfac;

  // Recursion to the next 3j coefficient 
  x = c1 * thrcof[lstep-1] + c2 * thrcof[lstep-2];
  thrcof[lstep] = x;
  sumfor = sum1;
  sum1 += x * x;
  if (lstep == nfin) goto L100;

  // See if last unnormalized 3j coefficient exceeds srhuge 

  if (fabs(x) < srhuge) goto L80;

  // This is reached if last 3j coefficient larger than srhuge, 
  // so that the recursion series thrcof(1), ... , thrcof(lstep) 
  // has to be rescaled to prevent overflow 

  // mscale = mscale + 1 
  for (i = 1; i <= lstep; ++i) {
    if (fabs(thrcof[i]) < srtiny) thrcof[i] = zero;
    thrcof[i] /= srhuge;
  }
  sum1 /= huge;
  sumfor /= huge;
  x /= srhuge;

  // As long as abs(c1) is decreasing, the recursion proceeds towards 
  // increasing 3j values and, hence, is numerically stable.  Once 
  // an increase of abs(c1) is detected, the recursion direction is 
  // reversed. 

L80:
  if (c1old - fabs(c1) > 0.0) goto L30;

  //  Keep three 3j coefficients around mmatch for comparison later 
  //  with backward recursion values. 

L100:
  // mmatch = m2 - 1 
  nstep2 = nfin - lstep + 3;
  x1 = x;
  x2 = thrcof[lstep-1];
  x3 = thrcof[lstep-2];

  //  Starting backward recursion from m2max taking nstep2 steps, so 
  //  that forwards and backwards recursion overlap at the three points 
  //  m2 = mmatch+1, mmatch, mmatch-1. 

  nfinp1 = nfin + 1;
  nfinp2 = nfin + 2;
  nfinp3 = nfin + 3;
  thrcof[nfin] = srtiny;
  sum2 = tiny;

  m2 = m2max + two;
  lstep = 1;
L110:
  ++lstep;
  m2 -= one;
  m3 = -m1 - m2;
  oldfac = newfac;
  a1s = (l2-m2+two) * (l2+m2-one) * (l3+m3+two) * (l3-m3-one);
  newfac = sqrt(a1s);
  dv = (l1+l2+l3+one) * (l2+l3-l1) - (l2-m2+one) * (l3+m3+one)
                                   - (l2+m2-one) * (l3-m3-one);
  c1 = -dv / newfac;
  if (lstep > 2) goto L120;

  // if m2 = m2max + 1 the third term in the recursion equation vanishes 

  y = srtiny * c1;
  thrcof[nfin - 1] = y;
  if (lstep == nstep2) goto L200;
  sumbac = sum2;
  sum2 += y * y;
  goto L110;

L120:
  c2 = -oldfac / newfac;

  // Recursion to the next 3j coefficient 

  y = c1 * thrcof[nfinp2 - lstep] + c2 * thrcof[nfinp3 - lstep];

  if (lstep == nstep2) goto L200;

  thrcof[nfinp1 - lstep] = y;
  sumbac = sum2;
  sum2 += y * y;

  // See if last 3j coefficient exceeds SRHUGE 

  if (fabs(y) < srhuge) goto L110;

  // This is reached if last 3j coefficient larger than srhuge, 
  // so that the recursion series thrcof(nfin), ... , thrcof(nfin-lstep+1)    
  // has to be rescaled to prevent overflow. 

  // mscale = mscale + 1 
  for (i = 1; i <= lstep; ++i) {
    index = nfin - i + 1;
    if (fabs(thrcof[index]) < srtiny) thrcof[index] = zero;
    thrcof[index] /= srhuge;
  }
  sum2 /= huge;
  sumbac /= huge;

  goto L110;

  //  The forward recursion 3j coefficients x1, x2, x3 are to be matched 
  //  with the corresponding backward recursion values y1, y2, y3. 

L200:
  y3 = y;
  y2 = thrcof[nfinp2-lstep];
  y1 = thrcof[nfinp3-lstep];

  //  Determine now ratio such that yi = ratio * xi  (i=1,2,3) holds 
  //  with minimal error. 

  ratio = (x1*y1 + x2*y2 + x3*y3) / (x1*x1 + x2*x2 + x3*x3);
  nlim = nfin - nstep2 + 1;

  if (fabs(ratio) < one) goto L211;
  for (n = 1; n <= nlim; ++n)
    thrcof[n] = ratio * thrcof[n];
  sumuni = ratio * ratio * sumfor + sumbac;
  goto L230;

L211:
  ++nlim;
  ratio = one / ratio;
  for (n = nlim; n <= nfin; ++n) 
    thrcof[n] = ratio * thrcof[n];
  sumuni = sumfor + ratio * ratio * sumbac;
  goto L230;

L220:
  sumuni = sum1;

  // Normalize 3j coefficients 

L230:
  cnorm = one / sqrt((l1+l1+one) * sumuni);

  // Sign convention for last 3j coefficient determines overall phase 

  sign1 = COPYSIGN(one,thrcof[nfin]);
  sign2 = ODD(int(fabs(l2-l3-m1)+eps)) ? -one : one;
  if (sign1 * sign2 <= 0.0) goto L235;
  else goto L236;

L235:
  cnorm = -cnorm;

L236:
  if (fabs(cnorm) < one) goto L250;

  for (n = 1; n <= nfin; ++n)
    thrcof[n] = cnorm * thrcof[n];
  return;

L250:
  thresh = tiny / fabs(cnorm);
  for (n = 1; n <= nfin; ++n) {
    if (fabs(thrcof[n]) < thresh) thrcof[n] = zero;
    thrcof[n] = cnorm * thrcof[n];
  }
} 

//-----------------------------------------------------------------------------//



//#include <av/basic.h>
//#include <iostream.h>
//-----------------------------------------------------------------------------//
//
// void ThreeJSymbolJ (double l2, double l3, double m2, double m3, 
//                     double &l1min, double &l1max, double *thrcof, int ndim, 
//                     int &errflag)
//
// Evaluate the Wigner 3j symbol 
//
//       f(l1) = (   l1    l2   l3 )
//               ( -m2-m3  m2   m3 )
//
// for all allowed values of l1, the other parameters being held fixed.
//
// Input Arguments:
// ----------------
//
//   double l2 
//   double l3
//   double m2
//   double m3		Parameters in 3j symbol.
//
//   int  ndim 		Declared length of thrcof in calling program.
//
// Output Arguments:
// -----------------
//
//   double &l1min	Smallest allowable l1 in 3j symbol.
//   double &l1max	Largest allowable l1 in 3j symbol.
//   double *thrcof	Set of 3j coefficients generated by evaluating the
//			3j symbol for all allowed values of l1.  
//			thrcof(i) will contain f(l1min+i), 
//			for i = 0, 2, ... , l1max+l1min.
//
//   int &errflag	Error flag.
//                 	errflag=0  No errors.
//                 	errflag=1  Either l2 < abs(m2) or l3 < abs(m3).
//                 	errflag=2  Either l2+abs(m2) or l3+abs(m3) non-integer.
//                 	errflag=3  l1max-l1min not an integer.
//                 	errflag=4  l1max less than l1min.
//                 	errflag=5  ndim less than l1max-l1min+1.
// Description:
// ------------
//
// Although conventionally the parameters of the vector addition
// coefficients satisfy certain restrictions, such as being integers
// or integers plus 1/2, the restrictions imposed on input to this
// subroutine are somewhat weaker. See, for example, Section 27.9 of
// Abramowitz and Stegun or Appendix C of Volume II of A. Messiah.
//
// The restrictions imposed by this subroutine are
//
//       1. l2 >= abs(m2) and l3 >= abs(m3)
//       2. l2+abs(m2) and l3+abs(m3) must be integers
//       3. l1max-l1min must be a non-negative integer, where
//          l1max=l2+l3 and l1min=max(abs(l2-l3),abs(m2+m3))
//
// If the conventional restrictions are satisfied, then these
// restrictions are also met.
//
// The user should be cautious in using input parameters that do
// not satisfy the conventional restrictions. For example, the
// the subroutine produces values of
//       f(L1) = ( l1  2.5  5.8)
//               (-0.3 1.5 -1.2)
// for l1=3.3,4.3,...,8.3 but none of the symmetry properties of the 3j 
// symbol, set forth on page 1056 of Messiah, is satisfied.
//
// The subroutine generates f(l1min), f(l1min+1), ..., f(l1max)
// where l1min and l1max are defined above. The sequence f(l1) is
// generated by a three-term recurrence algorithm with scaling to
// control overflow. Both backward and forward recurrence are used to
// maintain numerical stability. The two recurrence sequences are
// matched at an interior point and are normalized from the unitary
// property of 3j coefficients and Wigner's phase convention.
//
// The algorithm is suited to applications in which large quantum
// numbers arise, such as in molecular dynamics.
//
// References:
// -----------
//  1. Abramowitz, M., and Stegun, I. A., Eds., Handbook
//     of Mathematical Functions with Formulas, Graphs
//     and Mathematical Tables, NBS Applied Mathematics
//     Series 55, June 1964 and subsequent printings.
//  2. Messiah, Albert., Quantum Mechanics, Volume II,
//     North-Holland Publishing Company, 1963.
//  3. Schulten, Klaus and Gordon, Roy G., Exact recursive
//     evaluation of 3j and 6j coefficients for quantum-
//     mechanical coupling of angular momenta, J Math
//     Phys, v 16, no. 10, October 1975, pp. 1961-1970.
//  4. Schulten, Klaus and Gordon, Roy G., Semiclassical
//     approximations to 3j  and 6j coefficients for
//     quantum-mechanical coupling of angular momenta,
//     J Math Phys, v 16, no. 10, October 1975, pp. 1971-1988.
//  5. Schulten, Klaus and Gordon, Roy G., Recursive
//     evaluation of 3j and 6j coefficients, Computer
//     Phys Comm, v 11, 1976, pp. 269-278.
//  6. SLATEC library, category  C19, 
//     double precision algorithm DRC3JJ.F
//     Keywords: 3j coefficients, 3j symbols, Clebsch-Gordan coefficients, 
//               Racah coefficients, vector addition coefficients,
//               Wigner coefficients
//     Author:   Gordon, R. G., Harvard University
//               Schulten, K., Max Planck Institute
//     Revision history  (YYMMDD)
//     750101  DATE WRITTEN
//     880515  SLATEC prologue added by G. C. Nielson, NBS; parameters
//             HUGE and TINY revised to depend on D1MACH.
//     891229  Prologue description rewritten; other prologue sections
//             revised; LMATCH (location of match point for recurrences)
//             removed from argument list; argument errflag changed to serve
//             only as an error flag (previously, in cases without error,
//             it returned the number of scalings); number of error codes
//             increased to provide more precise error information;
//             program comments revised; SLATEC error handler calls
//             introduced to enable printing of error messages to meet
//             SLATEC standards. These changes were done by D. W. Lozier,
//             M. A. McClain and J. M. Smith of the National Institute
//             of Standards and Technology, formerly NBS.
//     910415  Mixed type expressions eliminated; variable C1 initialized; 
//             description of THRCOF expanded. These changes were done by
//             D. W. Lozier.
//  7. Rewritting of the SLATEX algorithm in C++ and adaption to the
//     Matpack C++ Numerics and Graphics Library by Berndt M. Gammel
//     in June 1997.
//
//-----------------------------------------------------------------------------//

inline int	odd	(int x){return(x&1);}
inline int	odd	(short x){return(x&1);}
inline int	odd	(long x){return(x&1);}
inline int	odd	(unsigned int x){return(x&1);}
inline int	odd	(unsigned short x){return(x&1);}
inline int	odd	(unsigned long x){return(x&1);}

void ThreeJSymbolJ (double l2, double l3, double m2, double m3, 
		    double &l1min, double &l1max, double *thrcof, int ndim, 
		    int &errflag)
{
  const double zero = 0.0, eps = 0.01, one = 1.0, two = 2.0, three = 3.0;

  int nfin, nlim, n, index, lstep, nfinp1, nfinp2, nfinp3, nstep2;
  double x, y, denom = 0.0, cnorm, ratio, a1, a2, c1, c2, l1, m1, x1, x2, x3, 
         y1, y2, y3, oldfac, dv, newfac, sumbac = 0.0, thresh, a1s, a2s, 
         sumfor, sumuni, sum1, sum2, c1old = 0.0, sign1, sign2;

  // Parameter adjustments
  --thrcof;

  errflag = 0;

  // "huge" is the square root of one twentieth of the largest floating
  // point number, approximately.
  double huge   = sqrt(DBL_MAX / 20.0),
         srhuge = sqrt(huge),
         tiny   = one / huge,
         srtiny = one / srhuge;

  // lmatch = zero
  m1 = -m2-m3;

  //  Check error conditions 1 and 2.
  if (l2 - fabs(m2) + eps < zero || l3 - fabs(m3) + eps < zero) {
    errflag = 1;
    WPrint("%s: %s  ThreeJSymbolJ l2-abs(m2) or l3-abs(m3) less than zero.");    
    return;
  } else if (fmod(l2 + fabs(m2) + eps, one) >= eps + eps || 
	     fmod(l3 + fabs(m3) + eps, one) >= eps + eps) {
    errflag = 2;
    WPrint("%s: %s ThreeJSymbolJ  l2+fabs(m2) or l3+fabs(m3) not integer.")
    return;
  }

  //  Limits for l1
  l1min = MAX(fabs(l2-l3),fabs(m1));
  l1max = l2 + l3;

  //  Check error condition 3.
  if (fmod(l1max - l1min + eps, one) >= eps + eps) {
    errflag = 3;
    WPrint("%s: %s ThreeJSymbolJ l1max-l1min not integer.");
    return;
  }
  if (l1min < l1max - eps) goto L20;
  if (l1min < l1max + eps) goto L10;

  //  Check error condition 4.
  errflag = 4;    
  WPrint("%s: %s ThreeJSymbolJ l1min greater than l1max.");
  return;

  //  This is reached in case that l1 can take only one value,
  //  i.e. l1min = l1max

L10:
  // lscale = 0
  thrcof[1] = (odd(int(fabs(l2+m2-l3+m3)+eps)) ? -one : one) / sqrt(l1min+l2+l3+one);
  return;

  //  This is reached in case that l1 takes more than one value,
  //  i.e. l1min < l1max.

L20:
  // lscale = 0
  nfin = int(l1max - l1min + one + eps);
  
  //  Check error condition 5.
  if (ndim - nfin < 0) {  
    errflag = 5;
    WPrint("%s: %s ThreeJSymbolJ Dimension of result array for 3j coefficients too small.");
    return;
  }

  //  Starting forward recursion from l1min taking nstep1 steps

  l1 = l1min;
  newfac = 0.0;
  c1 = 0.0;
  thrcof[1] = srtiny;
  sum1 = (l1 + l1 + one) * tiny;

  lstep = 1;

L30:
  ++lstep;
  l1 += one;

  oldfac = newfac;
  a1 = (l1+l2+l3+one) * (l1-l2+l3) * (l1+l2-l3) * (-l1+l2+l3+one);
  a2 = (l1 + m1) * (l1 - m1);
  newfac = sqrt(a1 * a2);
  if (l1 < one + eps)  goto L40;

  dv = -l2 * (l2+one) * m1 + l3 * (l3+one) * m1 + l1 * (l1-one) * (m3-m2);
  denom = (l1 - one) * newfac;
  
  if (lstep - 2 > 0) c1old = fabs(c1);
  c1 = -(l1 + l1 - one) * dv / denom;
  goto L50;

  //  If l1 = 1, (l1-1) has to be factored out of dv, hence

L40:
  c1 = -(l1 + l1 - one) * l1 * (m3 - m2) / newfac;

L50:
  if (lstep > 2) goto L60;

  //  if l1 = l1min + 1, the third term in the recursion equation vanishes, 
  //  hence
  x = srtiny * c1;
  thrcof[2] = x;
  sum1 += tiny * (l1 + l1 + one) * c1 * c1;
  if (lstep == nfin) goto L220;
  goto L30;

L60:
  c2 = -l1 * oldfac / denom;

  //  Recursion to the next 3j coefficient X

  x = c1 * thrcof[lstep - 1] + c2 * thrcof[lstep - 2];
  thrcof[lstep] = x;
  sumfor = sum1;
  sum1 += (l1 + l1 + one) * x * x;
  if (lstep == nfin) goto L100;

  //  See if last unnormalized 3j coefficient exceeds srhuge

  if (fabs(x) < srhuge) goto L80;

  //  This is reached if last 3j coefficient larger than srhuge,
  //  so that the recursion series thrcof(1), ... , thrcof(lstep)
  //  has to be rescaled to prevent overflow

  // lscale = lscale + 1
  for (int i = 1; i <= lstep; ++i) {
    if (fabs(thrcof[i]) < srtiny) thrcof[i] = zero;
    thrcof[i] /= srhuge;
  }
  sum1 /= huge;
  sumfor /= huge;
  x /= srhuge;

  //  As long as fabs(c1) is decreasing, the recursion proceeds towards
  //  increasing 3j values and, hence, is numerically stable.  once
  //  an increase of fabs(c1) is detected, the recursion direction is
  //  reversed.

L80:
  if (c1old - fabs(c1) <= 0.0) goto L100;
  else  goto L30;

  //  Keep three 3j coefficients around lmatch for comparison with
  //  backward recursion.

L100:
  // lmatch = l1 - 1
  x1 = x;
  x2 = thrcof[lstep - 1];
  x3 = thrcof[lstep - 2];
  nstep2 = nfin - lstep + 3;

  //  Starting backward recursion from l1max taking nstep2 steps, so
  //  that forward and backward recursion overlap at three points
  //  l1 = lmatch+1, lmatch, lmatch-1.

  nfinp1 = nfin + 1;
  nfinp2 = nfin + 2;
  nfinp3 = nfin + 3;
  l1 = l1max;
  thrcof[nfin] = srtiny;
  sum2 = tiny * (l1 + l1 + one);

  l1 += two;
  lstep = 1;
L110:
  ++lstep;
  l1 -= one;

  oldfac = newfac;
  a1s = (l1+l2+l3) * (l1-l2+l3-one) * (l1+l2-l3-one) * (-l1+l2+l3+two);
  a2s = (l1+m1-one) * (l1-m1-one);
  newfac = sqrt(a1s * a2s);

  dv = -l2 * (l2+one) * m1 + l3 * (l3+one) * m1 + l1 * (l1-one) * (m3-m2);

  denom = l1 * newfac;
  c1 = -(l1 + l1 - one) * dv / denom;
  if (lstep > 2) goto L120;

  // If l1 = l1max + 1, the third term in the recursion formula vanishes

  y = srtiny * c1;
  thrcof[nfin - 1] = y;
  sumbac = sum2;
  sum2 += tiny * (l1 + l1 - three) * c1 * c1;
  goto L110;

L120:
  c2 = -(l1 - one) * oldfac / denom;

  //  Recursion to the next 3j coefficient y

  y = c1 * thrcof[nfinp2 - lstep] + c2 * thrcof[nfinp3 - lstep];

  if (lstep == nstep2) goto L200;

  thrcof[nfinp1 - lstep] = y;
  sumbac = sum2;
  sum2 += (l1 + l1 - three) * y * y;

  // See if last unnormalized 3j coefficient exceeds SRHUGE

  if (fabs(y) < srhuge) goto L110;

  // This is reached if last 3j coefficient larger than srhuge,
  // so that the recursion series thrcof(nfin), ... ,thrcof(nfin-lstep+1) 
  // has to be rescaled to prevent overflow

  // lscale = lscale + 1
  for (int i = 1; i <= lstep; ++i) {
    index = nfin - i + 1;
    if (fabs(thrcof[index]) < srtiny) thrcof[index] = zero;
    thrcof[index] /= srhuge;
  }
  sum2 /= huge;
  sumbac /= huge;

  goto L110;

  // The forward recursion 3j coefficients x1, x2, x3 are to be matched
  // with the corresponding backward recursion values y1, y2, y3.

L200:
  y3 = y;
  y2 = thrcof[nfinp2 - lstep];
  y1 = thrcof[nfinp3 - lstep];

  //  Determine now ratio such that yi = ratio * xi  (i=1,2,3) holds
  //  with minimal error.

  ratio = (x1*y1 + x2*y2 + x3*y3) / (x1*x1 + x2*x2 + x3*x3);
  nlim = nfin - nstep2 + 1;

  if (fabs(ratio) < one) goto L211;

  for (n = 1; n <= nlim; ++n) 
    thrcof[n] = ratio * thrcof[n];
  sumuni = ratio * ratio * sumfor + sumbac;
  goto L230;

L211:
  ++nlim;
  ratio = one / ratio;
  for (n = nlim; n <= nfin; ++n)
    thrcof[n] = ratio * thrcof[n];
  sumuni = sumfor + ratio * ratio * sumbac;
  goto L230;

L220:
  sumuni = sum1;

  //  Normalize 3j coefficients

L230:
  cnorm = one / sqrt(sumuni);

  //  Sign convention for last 3j coefficient determines overall phase

  sign1 = COPYSIGN(one, thrcof[nfin]);
  sign2 = odd(int(fabs(l2 + m2 - l3 + m3) + eps)) ? -one : one;
  if (sign1 * sign2 <= 0.0) cnorm = -cnorm;

  if (fabs(cnorm) < one) goto L250;

  for (n = 1; n <= nfin; ++n) 
    thrcof[n] = cnorm * thrcof[n];

  return;

L250:
  thresh = tiny / fabs(cnorm);
  for (n = 1; n <= nfin; ++n) {
    if (fabs(thrcof[n]) < thresh) thrcof[n] = zero;
    thrcof[n] = cnorm * thrcof[n];
  }
} 

//-----------------------------------------------------------------------------//


/* Example of the program
int main(void){
  double l1min,l1max;
  double *thrcof;
  int ndim;
  int errflag;
  ndim=10;
  thrcof=new double [ndim];
  for (int k=0;k<ndim;k++) thrcof[k]=0.0;
ThreeJSymbolJ (1.5, 2.5, 1.5, 0.5, 
                     l1min, l1max, thrcof, ndim, 
	       errflag);
 cout<<l1min<<" "<<l1max<<endl;
 for (int k=0;k<ndim;k++) cout<<thrcof[k]<<endl;
  return 0;
}
*/



double ThreeJSymbol (double l1,double m1, double l2, double m2, double l3, double m3) {
  if (fabs(m1+m2+m3)>1E-7) return 0.0;
  if (fabs(m1)-0.01>l1) return 0.0; //unphysical
  if (fabs(m2)-0.01>l2) return 0.0;
  if (fabs(m3)-0.01>l3) return 0.0; 
  //  double l1 = 1, l2 = 1, l3 = 1, m1 = 0;   // integer values
  double m2min = MAX(-l2,-l3-m1),
         m2max = MIN(l2,l3-m1);

  int    n = int(m2max-m2min+1+0.1), errflag;

  double *cof = new double[n];

  ThreeJSymbolM (l1,l2,l3,m1, m2min,m2max, cof,n, errflag);
  // std::cout<<"data "<<m2<<" - "<<m2min<<" m2max= "<<m2max<<" round= "<<" ";
  // for (int i=0;i<n;i++) std::cout<<cof[i]<<std::endl;
  // cout<<cof[Nint(m2-m2min)]<<endl;
    if (errflag!=0) {delete[] cof; return 0;}
  else {
    double ret=cof[int(m2-m2min+0.1)]; //ret>=0 integer 0.1 insurance
    delete [] cof;
    return ret;
  }
}
double ClebschGordan (double l1,double m1, double l2, double m2, double l3, double m3) {
  return PARITY(int(l1+m3+3.*l2+0.1))* 
  sqrt(2.0*l3+1.0)*ThreeJSymbol (l1,m1, l2, m2, l3, -m3); 
  //parity of positive integer number 
}
#undef MAX
#undef MIN
#undef COPYSIGN
#undef ODD
  //#undef ABS
}
#endif

