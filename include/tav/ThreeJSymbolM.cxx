/*
Copyright (C) [2023] [Alexander Volya]
This code is licensed under the GNU GPL v3, see LICENSE file 
For more details and acknowledgments, see the NOTICE file.
*/


/*! 
\author Alexander Volya  <http://www.volya.net>
\file ThreeJSymbolM.cxx
\brief Calculation of three-j symbols and Clebsch-Gordan coefficients
\date 09/17/07
- Original formtran version was usued
- All input are integers twice the value of original spin
- bitshifts are used and parity from \ref ref_parity


Integer
ThreeJSymbol check for |m|<=j for all input;
 */
#ifndef __THREEJSYMBOLM_CXX__
#define __THREEJSYMBOLM_CXX__
#include <cmath>
#include <cstdlib>
//note abs(int) is in cstdlib  
#ifndef WPrint  //if debug is used this will be defined
#define WPrint(x)  //by default disable waringngs
#endif
#ifndef DBL_MAX
#define DBL_MAX  1.797693134862315e+308
#endif
#define MAX(a,b) ((a>b)?a:b)
#define MIN(a,b) ((a<b)?a:b)

namespace tav{
using std::abs;
/*
* SOME NOTES WHEN CONVERTING FORTRAN ROUTINES TO C++
* r1mach(n) returns:
*      FORTRAN                             C++
* d(1)=2.225073858507201e-308   DBL_MIN = 2.225073858507201e-308
*#define DBL_MAX  1.797693134862315e+308
*#include "compat.h"
*#include <unistd.h>
*#include <stdlib.h>
*#include <string.h>
* d(3)=1.110223024625157e-16    0.5 * DBL_EPSILON
* d(4)=2.220446049250313e-16    DBL_EPSILON= 2.220446049250313e-16
* d(5)=0.3010299956639812       log10(basis)
* double d_int(double*) rounds towards zero

 */


/*!
\brief Evaluate Wigner 3j symbol for all m-values

*-----------------------------------------------------------------------------*
*
*
* Evaluate the Wigner 3j symbol in array
*\f[
* g(m_2)=\left(\begin{array}{ccc}
* l_{1} & l_{2} & l_{3}\\
* m_{1} & m_{2} & -m_{1}-m_2 \end{array}\right)
* \f]
*
* for all allowed values of m2, the other parameters being held fixed.
*
*
* \par Return 
* the return integer is an error flag
*                 -	errflag=0  No errors.
*                 -	errflag=1  Either l1 < abs(m1) or l1+abs(m1) non-integer.
*                 -	errflag=2  abs(l1-l2)<= l3 <= l1+l2 not satisfied.
*                 -	errflag=3  l1+l2+l3 not an integer.
*                 -	errflag=4  m2max-m2min not an integer.
*                 -	errflag=5  m2max less than m2min.
* No check on array dimension
* \par Description:
* 
*
*
*
* The restrictions imposed by this subroutine are
*
*       -# l1 >= abs(m1) and l1+abs(m1) must be an integer
*       -# abs(l1-l2) <= l3 <= l1+l2
*       -# l1+l2+l3 must be an integer
*       -# m2max-m2min must be an integer, where
*          m2max=min(l2,l3-m1) and m2min=max(-l2,-l3-m1)
*
*
* The user should be cautious in using input parameters that do
* not satisfy the conventional restrictions. For example, the
* the subroutine produces values of
*       g(m2) = (0.75 1.50   1.75  )
*               (0.25  m2  -0.25-m2)
* for m2=-1.5,-0.5,0.5,1.5 but none of the symmetry properties of the
* 3j symbol, set forth on page 1056 of Messiah, is satisfied.
*
* The subroutine generates g(m2min), g(m2min+1), ..., g(m2max) 
* where m2min and m2max are defined above. The sequence g(m2) is 
* generated by a three-term recurrence algorithm with scaling to 
* control overflow. Both backward and forward recurrence are used to 
* maintain numerical stability. The two recurrence sequences are 
* matched at an interior point and are normalized from the unitary 
* property of 3j coefficients and Wigner's phase convention. 
*
* The algorithm is suited to applications in which large quantum 
* numbers arise, such as in molecular dynamics. 
*
* \par References:
* 
*  -# Abramowitz, M., and Stegun, I. A., Eds., Handbook
*     of Mathematical Functions with Formulas, Graphs
*     and Mathematical Tables, NBS Applied Mathematics
*     Series 55, June 1964 and subsequent printings.
*  -# Messiah, Albert., Quantum Mechanics, Volume II,
*     North-Holland Publishing Company, 1963.
*  -# Schulten, Klaus and Gordon, Roy G., Exact recursive
*     evaluation of 3j and 6j coefficients for quantum-
*     mechanical coupling of angular momenta, J Math
*     Phys, v 16, no. 10, October 1975, pp. 1961-1970.
*  -# Schulten, Klaus and Gordon, Roy G., Semiclassical
*     approximations to 3j  and 6j coefficients for
*     quantum-mechanical coupling of angular momenta,
*     J Math Phys, v 16, no. 10, October 1975, pp. 1971-1988.
*  -# Schulten, Klaus and Gordon, Roy G., Recursive
*     evaluation of 3j and 6j coefficients, Computer
*     Phys Comm, v 11, 1976, pp. 269-278.
*  -# SLATEC library, category  C19, 
*     double precision algorithm DRC3JM.F
*     Keywords: 3j coefficients, 3j symbols, Clebsch-Gordan coefficients, 
*               Racah coefficients, vector addition coefficients,
*               Wigner coefficients
*     Author:   Gordon, R. G., Harvard University
*               Schulten, K., Max Planck Institute
*     Revision history  (YYMMDD)
*     750101  DATE WRITTEN 
*     880515  SLATEC prologue added by G. C. Nielson, NBS; parameters 
*             HUGE and TINY revised to depend on D1MACH. 
*     891229  Prologue description rewritten; other prologue sections 
*             revised; MMATCH (location of match point for recurrences) 
*             removed from argument list; argument IER changed to serve 
*             only as an error flag (previously, in cases without error, 
*             it returned the number of scalings); number of error codes 
*             increased to provide more precise error information; 
*             program comments revised; SLATEC error handler calls 
*             introduced to enable printing of error messages to meet 
*             SLATEC standards. These changes were done by D. W. Lozier, 
*             M. A. McClain and J. M. Smith of the National Institute 
*             of Standards and Technology, formerly NBS. 
*     910415  Mixed type expressions eliminated; variable C1 initialized; 
*             description of THRCOF expanded. These changes were done by 
*             D. W. Lozier.
*  -# Rewritting of the SLATEX algorithm in C++ and adaption to the
*     Matpack C++ Numerics and Graphics Library by Berndt M. Gammel
*     in June 1997.
*  -# A. Volya full rewriting of algorithm using integers.
*
* \author Alexander Volya
* \date 10/24/2007

*/  

int ThreeJSymbolM (
    int l1, ///< Input 2*l1  (integer)
    int l2, ///< 2*l2 (integer)
    int l3, ///< 2*l3 (integer)
    int m1, ///< value 2*m1 (integer)
    int &m2min, ///< output 2*m2 (minimum)
    int &m2max, ///< output 2*m2 (maximum) 
    double *clebsch ///< output array of 3j-symbols g(0)->m2min   g(1)-> m2min+
		    ) 
{
  const double zero = 0.0;

  int nfin, nlim, i, n, index, lstep,  nfinp2, nfinp3, nstep2;
  double oldfac,  newfac, sumbac = 0.0, thresh,  sumfor, sumuni, 
         sum1, sum2, x, y, x1, x2, x3, y1, y2, y3, cnorm, 
         ratio, c1, c2, c1old = 0.0;
  int m2,m3;




  // "huge" is the square root of one twentieth of the largest floating
  // point number, approximately.
  double huge   = sqrt(DBL_MAX / 20.0),
         srhuge = sqrt(huge),
         tiny   = 1.0 / huge,
         srtiny = 1.0 / srhuge;

  // lmatch = zero

  //  Check error conditions 1, 2, and 3. 
  if (l1 - abs(m1)  < zero 
      || (l1 + abs(m1))%2 == 1) {
  WPrint("ThreeJSymbolM l1-fabs(m1) less than zero or l1+fabs(m1) not integer.");
    return 1;

  } else if (l1+l2 < l3 || l1+l3 < l2 || l2+l3 < l1) {

   WPrint("ThreeJSymbolM l1, l2, l3 do not satisfy triangular condition.");
    return 2;
  } else if ((l1 + l2 + l3 )%2 ==1) {
     WPrint("ThreeJSymbolM l1+l2+l3 not integer.");
      return 3;
  }

  // limits for m2 
  m2min = MAX(-l2,-l3-m1);
  m2max = MIN(l2,l3-m1);

  // Check error condition 4. 
  if ((m2max - m2min)%2 == 1) {
    WPrint(" ThreeJSymbolM m2max-m2min not integer.");
    return 4;
  }
  if (m2min > m2max) {  
      WPrint(" ThreeJSymbolM m2min greater than m2max.");
      return 5;
  }
  if (m2min == m2max ) {
  // This is reached in case that m2 and m3 can take only one value. 
  clebsch[0] = ((((l2-l3-m1)>>1)&1) ? -1.0 : 1.0) / sqrt(double((l1+l2+l3+2)>>1));
  return 0;
  };

  // This is reached in case that M1 and M2 take more than one value. 


  //dimension is nfin+1
  nfin = ((m2max - m2min)>>1); //nfin++;
// we do not explicitly check of array is big enough in C++ 
// such checks are suppressed for the sake of speed. 
// array size >= nfin+1



  //  Start of forward recursion from m2 = m2min 

  m2 = m2min;
  clebsch[0] = srtiny;
  newfac = 0.0;
  c1 = 0.0;
  sum1 = tiny;

  lstep = 0;
L30:
  ++lstep;
  m2 += 2;
  m3 = -m1 - m2;

  oldfac = newfac;
  newfac = sqrt(double(((l2 - m2 + 2) * (l2 + m2) * (l3 + m3 + 2) * (l3 - m3))>>4));

  if (lstep > 1) c1old = fabs(c1);

  c1 = 
      (((l2-m2+2) * (l3+m3+2)+ (l2+m2-2) * (l3-m3-2)-(l1+l2+l3+2) * (l2+l3-l1))>>2)/ newfac;

  if (lstep <= 1) {

  //  If m2 = m2min + 1, the third term in the recursion equation vanishes,    
  //  hence 

  x = srtiny * c1;
  clebsch[1] = x;
  sum1 += tiny * c1 * c1;
  if (lstep == nfin) goto L220;
  goto L30;
  }

  c2 = -oldfac / newfac;

  // Recursion to the next 3j coefficient 
  x = c1 * clebsch[lstep-1] + c2 * clebsch[lstep-2];
  clebsch[lstep] = x;
  sumfor = sum1;
  sum1 += x * x;
  if (lstep == nfin) goto L100;

  // See if last unnormalized 3j coefficient exceeds srhuge 

  if (fabs(x) < srhuge) goto L80;

  // This is reached if last 3j coefficient larger than srhuge, 
  // so that the recursion series clebsch(1), ... , clebsch(lstep) 
  // has to be rescaled to prevent overflow 

  // mscale = mscale + 1 
  for (i = 0; i <= lstep; ++i) {
    if (fabs(clebsch[i]) < srtiny) clebsch[i] = zero;
    clebsch[i] /= srhuge;
  }
  sum1 /= huge;
  sumfor /= huge;
  x /= srhuge;

  // As long as abs(c1) is decreasing, the recursion proceeds towards 
  // increasing 3j values and, hence, is numerically stable.  Once 
  // an increase of abs(c1) is detected, the recursion direction is 
  // reversed. 

L80:
  if (c1old - fabs(c1) > 0.0) goto L30;

  //  Keep three 3j coefficients around mmatch for comparison later 
  //  with backward recursion values. 

L100:
  // mmatch = m2 - 1 
  nstep2 = nfin - lstep + 2;
  x1 = x;
  x2 = clebsch[lstep-1];
  x3 = clebsch[lstep-2];

  //  Starting backward recursion from m2max taking nstep2 steps, so 
  //  that forwards and backwards recursion overlap at the three points 
  //  m2 = mmatch+1, mmatch, mmatch-1. 


  nfinp2 = nfin + 1;
  nfinp3 = nfin + 2;
  clebsch[nfin] = srtiny;
  sum2 = tiny;

  m2 = m2max + 4;
  lstep = 0;
L110:
  ++lstep;
  m2 -= 2;
  m3 = -m1 - m2;
  oldfac = newfac;
  newfac = sqrt(double(((l2-m2+4) * (l2+m2-2) * (l3+m3+4) * (l3-m3-2))>>4));

  c1 = -0.25*((l1+l2+l3+2) * (l2+l3-l1) - (l2-m2+2) * (l3+m3+2)
                                   - (l2+m2-2) * (l3-m3-2)) / newfac;

  c1 = ((  (l2-m2+2) * (l3+m3+2)
              + (l2+m2-2) * (l3-m3-2)- 
		(l1+l2+l3+2) * (l2+l3-l1))>>2) / newfac;


  if (lstep <= 1) {

  // if m2 = m2max + 1 the third term in the recursion equation vanishes 

  y = srtiny * c1;
  clebsch[nfin - 1] = y;
  if (lstep == nstep2) goto L200;
  sumbac = sum2;
  sum2 += y * y;
  goto L110;
  }

  c2 = -oldfac / newfac;

  // Recursion to the next 3j coefficient 

  y = c1 * clebsch[nfinp2 - lstep] + c2 * clebsch[nfinp3 - lstep];

  if (lstep == nstep2) goto L200;

  clebsch[nfin - lstep] = y;
  sumbac = sum2;
  sum2 += y * y;

  // See if last 3j coefficient exceeds SRHUGE 

  if (fabs(y) < srhuge) goto L110;

  // This is reached if last 3j coefficient larger than srhuge, 
  // so that the recursion series clebsch(nfin), ... , clebsch(nfin-lstep+1)    
  // has to be rescaled to prevent overflow. 

  // mscale = mscale + 1 
  for (i = 0; i <= lstep; ++i) {
    index = nfin - i ;
    if (fabs(clebsch[index]) < srtiny) clebsch[index] = zero;
    clebsch[index] /= srhuge;
  }
  sum2 /= huge;
  sumbac /= huge;

  goto L110;

  //  The forward recursion 3j coefficients x1, x2, x3 are to be matched 
  //  with the corresponding backward recursion values y1, y2, y3. 

L200:
  y3 = y;
  y2 = clebsch[nfinp2-lstep];
  y1 = clebsch[nfinp3-lstep];

  //  Determine now ratio such that yi = ratio * xi  (i=1,2,3) holds 
  //  with minimal error. 

  ratio = (x1*y1 + x2*y2 + x3*y3) / (x1*x1 + x2*x2 + x3*x3);
  nlim = nfin - nstep2;

  if (fabs(ratio) < 1.0) goto L211;
  for (n = 0; n <= nlim; ++n)
    clebsch[n] *= ratio ;
  sumuni = ratio * ratio * sumfor + sumbac;
  goto L230;

L211:
  ++nlim;
  ratio = 1.0 / ratio;
  for (n = nlim; n <= nfin; ++n) 
    clebsch[n] *= ratio;
  sumuni = sumfor + ratio * ratio * sumbac;
  goto L230;

L220:
  sumuni = sum1;

  // Normalize 3j coefficients 

L230: 
// Sign convention for last 3j coefficient determines overall phase 
//  sign1 = COPYSIGN(1.0,clebsch[nfin]);
//  sign2 = ODD((abs(l2-l3-m1))/2) ? -1.0 : 1.0;
//  if (sign1 * sign2 <= 0.0) goto L235;
//use A.V. sign convention and binary operations


  cnorm = ((clebsch[nfin]<0.)^(((l2-l3-m1)>>1)&1)) ? -1.0 / sqrt((l1+l1+2)/2.0 * sumuni) : 1.0 / sqrt((l1+l1+2)/2.0 * sumuni) ;

 
  if (fabs(cnorm) >= 1.0) {

  for (n = 0; n <= nfin; ++n)
    clebsch[n] *= cnorm;
  return 0;
  }

  thresh = tiny / fabs(cnorm);
  for (n = 0; n <= nfin; ++n) {
    if (fabs(clebsch[n]) < thresh) clebsch[n] = zero;
    clebsch[n] *= cnorm;
  }
  return 1;
} 
//! \brief Evaluate specific Wigner 3j-symbol
double ThreeJSymbol (int l1, int m1, int l2, int m2, int l3, int m3) {
  if ((m1+m2+m3)!=0) return 0.0;
  if (abs(m1)>l1) return 0.0; //unphysical
  if (abs(m2)>l2) return 0.0;
  if (abs(m3)>l3) return 0.0; 
  //  double l1 = 1, l2 = 1, l3 = 1, m1 = 0;   // integer values
  int m2min = MAX(-l2,-l3-m1),
         m2max = MIN(l2,l3-m1);

  int    n = ((m2max-m2min)/2+1);

  double *cof = new double[n];

  if (ThreeJSymbolM (l1,l2,l3,m1, m2min,m2max, cof)) {
  delete [] cof;
  return 0.0;
  }
  // std::cout<<"data "<<m2<<" - "<<m2min<<" m2max= "<<m2max<<" round= "<<" ";
  // for (int i=0;i<n;i++) std::cout<<cof[i]<<std::endl;
  // cout<<cof[Nint(m2-m2min)]<<endl;
  else {
    double ret=cof[(m2-m2min)/2]; //ret>=0 integer 0.1 insurance
    delete [] cof;
    return ret;
  }
}

/*! \brief Wigner 3j-symbol with time-reversal
\f[ (-1)^{j_{1}-m_{1}}\left(\begin{array}{ccc}
 j_{1} & \lambda & j_{2}\\
 -m_{1} & \mu & m_{2}\end{array}\right)
 \f]
 */
    double TThreeJSymbol (int l1, int m1, int l2, int m2, int l3, int m3) {
        return ((((l1-m1)>>1)&1) ?  -ThreeJSymbol (l1, -m1, l2, m2, l3, m3) : ThreeJSymbol (l1, -m1, l2, m2, l3, m3));
    }
    
//! \brief Evaluate Clebsch-Gordan coefficient
double ClebschGordan (int l1,int m1, int l2, int m2, int l3, int m3) {
    return (((l1+m3+3*l2)>>1)&1) ? 
	-sqrt(l3+1.0)*ThreeJSymbol (l1,m1, l2, m2, l3, -m3) : 
         sqrt(l3+1.0)*ThreeJSymbol (l1,m1, l2, m2, l3, -m3) ; 
  //parity of positive integer number 
}

#undef MAX
#undef MIN

}
#endif

